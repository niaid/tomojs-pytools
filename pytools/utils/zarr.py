import numpy as np
import dask.array as da
import zarr
import logging
from typing import List


logger = logging.getLogger(__name__)


def bin_shrink(img, shrink_dim=None):
    """Reduces image by a factor of 2 in xyz and performs averaging.

    :param img: an array-like object of 3 dimensions
    :param shrink_dim: an iterable for dimensions to perform operation on. Recommended to order from the fastest axis to
     slowest for performance.
    """
    input_type = img.dtype
    img = img.astype(np.float32)
    # When odd, set end index to -1 to drop odd entry
    stop_index = [-1 if s % 2 and s != 1 else None for s in img.shape]

    if shrink_dim is None:
        shrink_dim = range(img.ndim)[::-1]

    for i in shrink_dim:
        if img.shape[i] <= 1:
            continue
        idx1 = tuple(slice(0, stop_index[i], 2) if j == i % img.ndim else slice(None) for j in range(img.ndim))
        idx2 = tuple(slice(1, stop_index[i], 2) if j == i % img.ndim else slice(None) for j in range(img.ndim))

        img = (img[idx1] + img[idx2]) / 2

    return img.astype(input_type)


def build_pyramid(zarr_path, components: List[str], chunks=None, shrink=(-1, -2), overwrite=False):
    """
    Iteratively generate multiple resolutions of zarr arrays.

    The input array is named by the first items in the components. The remaining components are iteratively generated by
    reducing the resolution in the "shrink" dimensions, by a factor of 2.

    """
    store = zarr.DirectoryStore(zarr_path)
    arr = zarr.Array(store, read_only=True, path=components[0])

    source_image = da.from_array(arr, chunks=arr.chunks)

    if chunks is None:
        chunks = arr.chunks

    for output_component in components[1:]:
        binned_image = bin_shrink(source_image, shrink_dim=shrink).rechunk(chunks)

        da.to_zarr(
            binned_image,
            zarr_path,
            component=output_component,
            compressor=arr.compressor,
            dimension_separator=arr._dimension_separator,
            filters=arr.filters,
            compute=False,
            overwrite=overwrite,
            # dtype=arr.dtype.newbyteorder("="),
        ).compute()

        source_image = da.from_zarr(zarr_path, component=output_component)
